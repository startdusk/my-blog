(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{343:function(t,s,a){"use strict";a.r(s);var n=a(1),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"golang：如何测试未导出的函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#golang：如何测试未导出的函数"}},[t._v("#")]),t._v(" Golang：如何测试未导出的函数")]),t._v(" "),a("p",[t._v("在 Go 语言中，写单元测试是经常的事情，那么在测试的时候，尽量要提高测试的覆盖率，才能确保程序在可控范围。"),t._v("\n那么在 Go 语言中，函数的对外暴露的可见性是由函数首字母的大小写控制的，大写就是对外暴露，小写则是对外不暴露：")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" xxx\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对外暴露")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对外不暴露")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("一般情况下，写测试文件都是直接在同一个包内写测试文件，Go 语言中测试文件命名规则为：文件名 + _test.go，因为是在同一个包内写测试，所以不会有包内成员的可见性问题，但，如果我们想把测试文件统一放到一个文件下管理，问题就来了，要测试的函数就变成通过导包导入进来的，那么就有了成员可见 性的问题，那么解决的办法是，在要测试的包内新建 export_test.go 文件用来导出不导出的包，如：我们要测试下面的 a 函数")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" xxx\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对外暴露")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对外不暴露")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("那么，我们需要在同一个包下新建 export_test.go 文件：")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" xxx\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" TestA "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a\n")])])]),a("p",[t._v("这样，我们就把 a 函数桥接到了 TestA，TestA 是可对外暴露的，那么在测试的时候，调用 TestA 就是在调用 a。"),t._v("\n那么这样做的好处是：")]),t._v(" "),a("ul",[a("li",[t._v("1.我们没有修改任何代码，不会破坏原有的导出规则")]),t._v(" "),a("li",[t._v("2.使用 文件名 + _test.go 的形式在 Go 编译的时候不会把它编译进去，因为 _test 后缀的文件名，只对 go test 可见")])])])}),[],!1,null,null,null);s.default=e.exports}}]);